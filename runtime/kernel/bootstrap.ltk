"
Bootstrap Smalltalk kernel.
"

let bootstrapClassHierarchy := #(
    "Core classes"
    (nil ProtoObject pointers () ())
    (ProtoObject Object pointers () ())

    (Object Behavior pointers (superclass methodDict format layout) ())
        (Behavior ClassDescription pointers (instanceVariables organization) ())
            (ClassDescription Class pointers (subclasses name classPool sharedPools environment category traitComposition localSelectors) ())
            (ClassDescription Metaclass pointers (thisClass traitComposition localSelectors) ())

    (Object UndefinedObject pointers () ())
    (Object Boolean pointers () ())
        (Object True pointers () ())
        (Object False pointers () ())

    "Magnitude"
    (Object Magnitude pointers () ())
        (Magnitude Character immediate () ())
        (Magnitude Number pointers () ())
            (Number Float pointers () ())
                (Float BoxedFloat64 words () ())
                (Float SmallFloat immediate () ())
            (Number Fraction pointers () ())
            (Number Integer pointers () ())
                    (Integer LargeInteger bytes () ())
                            (LargeInteger LargeNegativeInteger bytes () ())
                            (LargeInteger LargePositiveInteger bytes () ())
                    (Integer SmallInteger immediate () (minVal maxVal))
        (Magnitude LookupKey pointers (key) ())
            (LookupKey Association pointers (value) ())
                (Association LiteralVariable pointers () ())
                    (LiteralVariable ClassVariable pointers () ())
                    (LiteralVariable GlobalVariable pointers () ())
                    (LiteralVariable WorkspaceVariable pointers () ())
    (Object Point pointers () ())

    "Collections"
    (Object Collection pointers () ())
        (Collection HashedCollection pointers (tally array) ())
            (HashedCollection Dictionary pointers () ())
                (Dictionary IdentityDictionary pointers () ())
                    (IdentityDictionary SystemDictionary pointers () ())
                (Dictionary MethodDictionary pointers (values) ())
            (HashedCollection Set pointers () ())
                (Set IdentitySet pointers () ())
                (Set WeakSet pointers () ())
        (Collection SequenceableCollection pointers () ())
            (SequenceableCollection OrderedCollection pointers (array firstIndex lastIndex) ())
            (Collection ArrayedCollection pointers () ())
                (ArrayedCollection Array variablePointers () ())
                    (Array WeakArray variableWeakPointers () ())
                (ArrayedCollection ByteArray bytes () ())
                (ArrayedCollection String pointers () ())
                    (String ByteString bytes () ())
                    (String WideString words () ())
                    (String Symbol pointers () ())
                        (Symbol ByteSymbol bytes () ())
                        (Symbol WideSymbol words () ())

    "Context"
    (Array CompiledMethod variablePointers (entryPoint) ())

    (Object Message pointers (selector args lookupClass) ())
    (Object InstructionStream pointers (sender pc) ())
        (InstructionStream Context variablePointers (stackp method closureOrNil receiver) ())

    (Object BlockClosure variablePointers (outerContext startpc numArgs) ())
        (BlockClosure FullBlockClosure variablePointers (receiver) ())

    (Object Mutex pointers () ())
    (Object Semaphore pointers () ())

    "FFI"
   (Object ExternalAddress bytes () (wordSize))
    (Object ExternalObject pointers (handle) ())
        (ExternalObject ExternalFunction pointers (flags argTypes) ())
        (ExternalObject ExternalLibrary pointers (name) ())
        (ExternalObject ExternalStructure pointers () ())
            (ExternalStructure ExternalData pointers (type) ())

    (ByteArray Alien bytes () ())
    (Object UnsafeAlien pointers (nonPointerObject) ())
).

let superClassSlotIndex := 1.
let methodDictionarySlotIndex := 2.
Compiler objectModel
    superClassSlotIndex: superClassSlotIndex;
    methodDictionarySlotIndex: methodDictionarySlotIndex.

"Compute the size of the instance side"
let classInstanceSizeDictionary := Compiler newDictionary.
bootstrapClassHierarchy do: [:classDefinition |
    let baseName := classDefinition at: 1.
    let name := classDefinition at: 2.
    let type := classDefinition at: 3.
    let instanceVariables := classDefinition at: 4.
    let metaInstanceVariables := classDefinition at: 5.

    let instanceSize := instanceVariables size.
    let metaInstanceSize := metaInstanceVariables size.
    baseName ifNotNil: [
        instanceSize := instanceSize + (classInstanceSizeDictionary at: baseName).
    ].

    classInstanceSizeDictionary at: name put: instanceSize.
].

"Compute the size of the meta side"
let metaclassInstanceSizeDictionary := Compiler newDictionary.
bootstrapClassHierarchy do: [:classDefinition |
    let baseName := classDefinition at: 1.
    let name := classDefinition at: 2.
    let type := classDefinition at: 3.
    let instanceVariables := classDefinition at: 4.
    let metaInstanceVariables := classDefinition at: 5.

    let metaInstanceSize := metaInstanceVariables size.
    baseName ifNotNil: [
        metaInstanceSize := metaInstanceSize + (metaclassInstanceSizeDictionary at: baseName).
    ] ifNil: [
        metaInstanceSize := metaInstanceSize + (classInstanceSizeDictionary at: #Class).
    ].

    metaclassInstanceSizeDictionary at: name put: metaInstanceSize.
].

"Build the class objects"
let metaClassSize := classInstanceSizeDictionary at: #Metaclass.
bootstrapClassHierarchy do: [:classDefinition |
    let baseName := classDefinition at: 1.
    let name := classDefinition at: 2.
    let type := classDefinition at: 3.
    let instanceVariables := classDefinition at: 4.
    let metaInstanceVariables := classDefinition at: 5.

    let instanceSize := classInstanceSizeDictionary at: name.
    let metaInstanceSize := metaclassInstanceSizeDictionary at: name.

    "Create the meta class"
    let metaClass := Compiler objectModel newObjectWithPointers: metaClassSize.
    (Compiler objectModel registerClass: metaClass)
        type: #pointers;
        instanceVariables: metaInstanceVariables.

    "Create the class"
    let class := Compiler objectModel newObjectWithPointers: metaInstanceSize.
    Compiler objectModel setObject: class class: metaClass.
    (Compiler objectModel registerClass: class)
        type: type;
        instanceVariables: instanceVariables.

    "Link the super classes."
    baseName ifNotNil: [
        let superClass := _GlobalNamespace at: baseName.
        Compiler objectModel
            setObject: class slot: superClassSlotIndex value: superClass.

        let superMeta := Compiler objectModel getObjectClass: superClass.
        Compiler objectModel
            setObject: metaClass slot: superClassSlotIndex value: superMeta.
    ].

    Global named: name type: _DynamicObject value: class
].

"Method dictionary definition."
let methodDictionarySize := classInstanceSizeDictionary at: #MethodDictionary.
let MethodDictionary_initialize := [ :self<MethodDictionary> |
    tally := 0.
    array := #().
    values := #().
].

let MethodDictionary_new := [
    let result := Compiler objectModel newObjectWithPointers: methodDictionarySize.
    Compiler objectModel setObject: result class: MethodDictionary.
    MethodDictionary_initialize value: result.
    result.
].

"Tricky parts on the class hierarchy."
let classHierarchyShortCirtcuit := [
    "Make 'Class' the super class of 'ProtoObject class'"
    let protoObjectMeta := Compiler objectModel getObjectClass: ProtoObject.
    Compiler objectModel setObject: protoObjectMeta slot: superClassSlotIndex value: Class.

    "Set the classes of the special literals."
    Compiler objectModel
        setObject: nil class: UndefinedObject;
        setObject: true class: True;
        setObject: false class: False.

    "Instantiate the special literals."
    Constant
        named: #nil type: _DynamicObject value: (Compiler objectModel setObject: (Compiler objectModel newObjectWithPointers: 0) class: UndefinedObject);
        named: #true type: _DynamicObject value: (Compiler objectModel setObject: (Compiler objectModel newObjectWithPointers: 0) class: True);
        named: #false type: _DynamicObject value: (Compiler objectModel setObject: (Compiler objectModel newObjectWithPointers: 0) class: False).

    "Finish this part"
    bootstrapClassHierarchy do: [:classDefinition |
        let name := classDefinition at: 2.

        "Create the method dictionaries."
        let class := _GlobalNamespace at: name.
        let classMethodDictionary := MethodDictionary_new value.

        Compiler objectModel
            setObject: classMethodDictionary class: MethodDictionary;
            setObject: class slot: methodDictionarySlotIndex value: classMethodDictionary.

        let metaClass := Compiler objectModel getObjectClass: class.
        let metaClassMethodDictionary := MethodDictionary_new value.
        Compiler objectModel
            setObject: metaClassMethodDictionary class: MethodDictionary;
            setObject: metaClass slot: methodDictionarySlotIndex value: metaClassMethodDictionary.

        "Set the metaclass class. Parallel hierarchy shortcircuiting."
        Compiler objectModel setObject: metaClass class: Metaclass.
    ]
].
classHierarchyShortCirtcuit value.

"More of the method dictionary methods."
let MethodDictionary_scanFor := [<UIntPointer> :self<MethodDictionary> :key |
    <localReturn>
    <selector: #scanFor:>
    let finish<UIntPointer> := array basicSize.
    finish == 0 ifTrue: [
        ^ 0
    ].

    let start<UIntPointer> := (key identityHash \\ finish) + 1.
    let element := nil.

    "Search from (hash mod size) to the end."
    start to: finish do: [:index<UIntPointer> |
        ((element := array basicAt: index) == nil or: [element == key])
            ifTrue: [^ index ]
    ].

    "Search from 1 to where we started."
    1 to: start-1 do: [:index<UIntPointer> |
        ((element := array basicAt: index) == nil or: [element == key])
            ifTrue: [^ index ]
    ].

    ^ 0  "No match AND no empty slot"
].

let MethodDictionary_atOrNil := [:self<MethodDictionary> :key |
    <localReturn>
    <selector: #atOrNil:>
    let index := MethodDictionary_scanFor #{self . key}.
    ^ index ~= 0 ifTrue: [values basicAt: index] ifFalse: [nil].
].

let MethodDictionary_atPutNoCheck := [:self<MethodDictionary> :key :value |
    <selector: #at:putNoCheck:>
    let index := MethodDictionary_scanFor #{self . key}.
    array basicAt: index put: key.
    value basicAt: index put: value.
].

let MethodDictionary_grow := [ :self<MethodDictionary> |
    <selector: #grow>

    let oldKeys := array.
    let oldValues := values.
    let oldSize := array basicSize.
    let newSize := oldSize * 2.
    newSize < 8 ifTrue: [ newSize := 8 ].

    array := Array basicNew: newSize.
    values := Array basicNew: newSize.

    1 to: oldSize do: [:i |
        let key := oldKeys basicAt: i.
        let value := oldValues basicAt: i.
        key ifNotNil: [
            MethodDictionary_atPutNoCheck #{self. key. value}.
        ]
    ].

    tally := 0.
].

let MethodDictionary_atPut := [:self<MethodDictionary> :key :value |
    <selector: #at:put:>

    let index := MethodDictionary_scanFor #{self . key}.
    index = 0 ifTrue: [
        MethodDictionary_grow #{self}.
        index := MethodDictionary_scanFor #{self . key}
    ].

    array basicAt: index put: key.
    values basicAt: index put: value.
].
"Behavior methods"
let Behavior_superclass := [ :self<Behavior> | superclass ].
let Behavior_methodDict := [ :self<Behavior> | methodDict ].

let Behavior_lookupSelector := [ :self<Behavior> :selector |
    <localReturn>
    let position := self.
    [position == nil] whileFalse: [
        let result := MethodDictionary_atOrNil value: (Behavior_methodDict value: position) value: selector.
        result ifNotNil: [^ result].
        position := (Behavior_superclass value: position) castTo: Behavior
    ].

    ^ nil
].

Compiler objectModel lookupSelectorFunction: Behavior_lookupSelector.

"Allow putting things on the method dictionaries."
[ :self<Behavior> |
    MethodDictionary_atPut value: methodDict value: #methodDict value: Behavior_methodDict
] value: Behavior.

MethodDictionary_atPut value: MethodDictionary methodDict value: #at:put: value: MethodDictionary_atPut.

"Put the bootstrap methods in their method dictionary"
ProtoObject methodDict at: #yourself put: [:self<ProtoObject> | self].

Behavior methodDict
    at: #superclass put: Behavior_superclass;
    at: #lookupSelector put: Behavior_lookupSelector.

MethodDictionary methodDict
    at: #atOrNil: put: MethodDictionary_atOrNil;
    at: #at:putNoCheck: put: MethodDictionary_atPutNoCheck;
    at: #grow put: MethodDictionary_grow.

CompiledMethod methodDict
    at: #entryPoint put: [:self<CompiledMethod> | entryPoint];
    at: #entryPoint: put: [:self<CompiledMethod> :newEntryPoint | entryPoint := newEntryPoint. self].

"Some functions related to the object model."
Compiler objectModel
    convertArrayFunction: [:array |
        let result := Array basicNew: array size.
        1 to: array size do: [:i | result basicAt: i put: (array basicAt: i)].
        result
    ];
    convertByteSymbolFunction: [:array |
        let result := ByteSymbol basicNew: array size.
        1 to: array size do: [:i | result basicAt: i put: (array basicAt: i)].
        "TODO: Compute the identity hash."
        result
    ];
    convertByteStringFunction: [:array |
        let result := ByteString basicNew: array size.
        1 to: array size do: [:i | result basicAt: i put: (array basicAt: i)].
        result
    ];
    convertMethodContextMetadataFunction: [:entryPoint :literals |
        let result := CompiledMethod basicNew: literals size.
        result entryPoint: entryPoint.
        1 to: literals size do: [:i | result basicAt: i put: (literals at: i)].
        result
    ];
    yourself.


"Message send"
Constant named: #superSendTrampoline value: [ :selector<ObjectModel ObjectHeader pointer> :lookupStart<ObjectModel ObjectHeader pointer> |
    <smalltalk_supersend>
    <localReturn>
    LibC printf #{c'TODO: Super send selector %p lookupStart %p.\n' . (selector reinterpretCastTo: Void pointer) . (lookupStart reinterpretCastTo: Void pointer)}.
    ^ 0
].

Constant named: #sendTrampoline value: [ :selector<ObjectModel ObjectHeader pointer> :receiver<ObjectModel ObjectHeader pointer> |
    <smalltalk_send>
    <localReturn>
    let receiverClass := ObjectModel getObjectClass #{receiver}.
    LibC printf #{c'TODO: Send selector %p receiver %p class %p\n' . (selector reinterpretCastTo: Void pointer) . (receiver reinterpretCastTo: Void pointer) . (receiverClass reinterpretCastTo: Void pointer)}.

    "let method := Behavior_lookupSelector #{receiverClass reinterpretCastTo: Behavior. selector reinterpretCastTo: _DynamicObject}.
    LibC printf #{c'Method %p\n' . (method reinterpretCastTo: Void pointer)}."
    ^ 0
].

Compiler objectModel
    sendTrampolineFunction: sendTrampoline;
    superSendTrampolineFunction: superSendTrampoline;
    yourself

Collection category: 'testing' methods: {
:[isEmptyOrNil
	"Answer whether the receiver contains any elements, or is nil.  Useful in numerous situations where one wishes the same reaction to an empty collection or to nil"

	^ self isEmpty
].

:[isEmpty
	"Answer whether the receiver contains any elements."

	^self size = 0
].

:[isNotEmpty
	"Answer whether the receiver contains any elements."

	^self size ~= 0
].

}.

UndefinedObject category: 'testing' methods: {
:[isEmptyOrNil
	^ true
].
}.

SequenceableCollection category: 'accessing' methods: {
:[, otherCollection
	"Concatenate two Strings or Collections."

	^ self copyReplaceFrom: self size + 1
		  to: self size
		  with: otherCollection
"
#(2 4 6 8) , #(who do we appreciate)
((2989 storeStringBase: 16) copyFrom: 4 to: 6) , ' boy!'
"
].

:[replaceFrom: start to: stop with: replacement startingAt: repStart
	"This destructively replaces elements from start to stop in the receiver
	starting at index, repStart, in the sequenceable collection,
	replacementCollection. Answer the receiver. No range checks are
	performed."

	| index repOff |
	repOff := repStart - start.
	index := start - 1.
	[(index := index + 1) <= stop]
		whileTrue: [self at: index put: (replacement at: repOff + index)]
].

:[copyFrom: start to: stop
	"Answer a copy of a subset of the receiver, starting from element at
	index start until element at index stop."

	| newSize |
	newSize := stop - start + 1.
	^(self species new: newSize)
		replaceFrom: 1
		to: newSize
		with: self
		startingAt: start
].

:[copyReplaceFrom: start to: stop with: replacementCollection
	"Answer a copy of the receiver satisfying the following conditions: If
	stop is less than start, then this is an insertion; stop should be exactly
	start-1, start = 1 means insert before the first character, start = size+1
	means append after last character. Otherwise, this is a replacement; start
	and stop have to be within the receiver's bounds."

	| newSequenceableCollection newSize endReplacement |
	newSize := self size - (stop - start + 1) + replacementCollection size.
	endReplacement := start - 1 + replacementCollection size.
	newSequenceableCollection := self species new: newSize.
	start > 1 ifTrue:[
		newSequenceableCollection
			replaceFrom: 1
			to: start - 1
			with: self
			startingAt: 1].
	start <= endReplacement ifTrue:[
		newSequenceableCollection
			replaceFrom: start
			to: endReplacement
			with: replacementCollection
			startingAt: 1].
	endReplacement < newSize ifTrue:[
		newSequenceableCollection
			replaceFrom: endReplacement + 1
			to: newSize
			with: self
			startingAt: stop + 1].
	^newSequenceableCollection
].

}.

SequenceableCollection category: 'enumerating' methods: {

:[do: aBlock
"Refer to the comment in Collection|do:."
1 to: self size do:
    [:index | aBlock value: (self at: index)]
].

:[doWithIndex: aBlock
"Refer to the comment in Collection|do:."
1 to: self size do:
    [:index | aBlock value: (self at: index) value: index]
].

}.

SequenceableCollection category: 'testing' methods: {
:[indexOf: anObject
    1 to: self size do: [:index |
        (self at: index) = anObject ifTrue: [ ^ index]
    ].
    ^ 0
]
}.

SequenceableCollection category: 'testing' methods: {
:[includes: anObject
	"Answer whether anObject is one of the receiver's elements."

	^ (self indexOf: anObject) ~= 0
]
}.

SequenceableCollection category: 'accessing ordinals' methods: {
:[first
    ^ self at: 1
].
:[second
    ^ self at: 2
].
:[third
    ^ self at: 3
].
:[fourth
    ^ self at: 4
].
:[fifth
    ^ self at: 5
].
:[sixth
    ^ self at: 6
].
:[seventh
    ^ self at: 7
].
:[eight
    ^ self at: 8
].
:[ninth
    ^ self at: 1
].

}

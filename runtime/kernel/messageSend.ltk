let ObjectHeader := ObjectModel ObjectHeader.
let Oop := ObjectHeader pointer.
let DNUSelector<_DynamicObject> := #doesNotUnderstand: .

Structure named: #_ArrayHeader slots: {
    #header => ObjectHeader.
    #slots => Oop array.
}.

Structure named: #_MethodDictionaryHeader slots: {
    #header => ObjectHeader.
    #tally => Oop.
    #array => _ArrayHeader pointer.
    #values => _ArrayHeader pointer.
}.

Structure named: #_BehaviorHeader slots: {
    #header => ObjectHeader.
    #superclass => _BehaviorHeader pointer.
    #methodDict => _MethodDictionaryHeader pointer.
}.

Structure named: #_CompiledMethod slots: {
    #header => ObjectHeader.
    #entryPoint => UIntPointer.
}.

"Message send"
Constant named: #_MethodDictionary_scanFor value: [ <UIntPointer> :this<_MethodDictionaryHeader pointer> :key<Oop> |
    <cdecl>
    <localReturn>

    let finish<UIntPointer> := ObjectModel getPointersBasicSize #{this value array}.
    finish == 0 ifTrue: [
        ^ 0
    ].

    let start<UIntPointer> := (ObjectModel getIdentityHash #{key} \\ finish) + 1.
    "LibC printf #{c'scanFor key %08X start: %p finish: %p\n' . ObjectModel getIdentityHash #{key} . start . finish}."
    let element<Oop> := nil.

    "Search from (hash mod size) to the end."
    start to: finish do: [:index<UIntPointer> |
        ((element := this value array value slots at: index) == nil or: [element == key])
            ifTrue: [^ index ]
    ].

    "Search from 1 to where we started."
    1 to: start-1 do: [:index<UIntPointer> |
        ((element := this value array value slots at: index) == nil or: [element == key])
            ifTrue: [^ index ]
    ].

    ^ 0
].

Constant named: #_MethodDictionary_atOrNil value: [ <Oop> :this<_MethodDictionaryHeader pointer> :key<Oop> |
    <cdecl>
    <localReturn>

    let index := _MethodDictionary_scanFor #{this . key}.
    ^ index ~= 0 ifTrue: [this value values value slots at: index] ifFalse: [nil].
].

Constant named: #sendLookupSelector value: [ <Oop> :behavior<_BehaviorHeader pointer> :selector<Oop> |
    <cdecl>
    <localReturn>
    let position := behavior.
    [ position ] whileNotNil: [
        "LibC printf #{c'Position %p\n' . position}."
        let methodDict := position value methodDict.

        let method := _MethodDictionary_atOrNil #{methodDict . selector}.
        method ifNotNil: [ ^ method].

        position := position value superclass.
    ].

    ^ nil
].

Constant named: #superSendTrampoline value: [ :selector<ObjectModel ObjectHeader pointer> :lookupStart<ObjectModel ObjectHeader pointer> |
    <smalltalk_supersend>
    <localReturn>
    LibC fprintf #{LibC stderr. c'TODO: Super send selector %p lookupStart %p.\n' . (selector reinterpretCastTo: Void pointer) . (lookupStart reinterpretCastTo: Void pointer)}.
    LibC abort #{}.
    ^ 0
].

Constant named: #sendTrampoline value: [ :selector<ObjectModel ObjectHeader pointer> :receiver<ObjectModel ObjectHeader pointer> |
    <smalltalk_send>
    <localReturn>
    "LibC printf #{c'Send %p selector [p: %p]\n' . receiver . selector}."

    "LibC printf #{c'Send selector [p: %p, ih: %08X, v: %.*s]\n' .
        selector . selector value identityHash . (ObjectModel getBytesObjectSize #{selector}) .  (ObjectModel getFirstFixedFieldPointer #{selector})}."

    let receiverClass := ObjectModel getObjectClass #{receiver} reinterpretCastTo: _BehaviorHeader pointer.
    "LibC printf #{c'receiver %p class %p\n' . receiver . receiverClass}."

    let method := sendLookupSelector #{receiverClass . selector}.
    method ifNil: [
        selector == (DNUSelector reinterpretCastTo: ObjectModel ObjectHeader pointer) ifTrue: [
            LibC fprintf #{LibC stderr. c'FATAL ERROR: Unhandled #doesNotUnderstand:\n'}.
            LibC abort #{}.
        ].

        LibC fprintf #{LibC stderr. c'TODO: Implement sending does not understand [%p]%p (#%.*s)\n'. receiverClass . receiver . (ObjectModel getBytesObjectSize #{selector}) .  (ObjectModel getFirstFixedFieldPointer #{selector})}.
        LibC abort #{}.
    ].

    "LibC printf #{c'Found method %p\n' . method}."

    let methodClass := ObjectModel getObjectClass #{method}.
    methodClass == (CompiledMethod reinterpretCastTo: Oop) ifTrue: [
        let compiledMethod := method reinterpretCastTo: _CompiledMethod pointer.
        let entryPoint := compiledMethod value entryPoint - 1 reinterpretCastTo: Void pointer.
        thisContext uncheckedReplaceFunctionWith: entryPoint.
    ] ifFalse: [
        LibC fprintf #{LibC stderr. c'TODO: dispatch to non compiled method\n'}.
        LibC abort #{}
    ].

    ^ 0
].

Compiler objectModel
    sendTrampolineFunction: sendTrampoline;
    superSendTrampolineFunction: superSendTrampoline;
    yourself
